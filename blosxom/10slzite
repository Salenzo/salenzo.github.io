package slzite;

use warnings;
use strict;
use English;
use File::Basename;
use Time::Local;
use File::Find;
use File::stat;
use File::Copy;
use File::Path;
use FileHandle;
use Data::Dumper;

sub start {
	# Ensure that this plugin is enabled only when building statically.
	return $blosxom::static_or_dynamic eq "static" ? 1 : 0;
}

sub template {
	return sub {
		my ($path, $chunk, $flavour) = @_;
		if ($flavour eq "rss") {
			# Use Blosxom's built-in RSS template.
			return join "", $blosxom::template{$flavour}{$chunk};
		} else {
			# Customized flavours are stored in the plugin directory.
			open(my $fh, "< $blosxom::plugin_dir/$chunk.$flavour");
			return join "", <$fh>;
		}
	};
}

sub story {
	my ($pkg, $path, $filename, $story_ref, $title_ref, $body_ref) = @_;

	# Parse the front matter into a global hash and strip it from the body.
	# Extract the title of the article from the Markdown source.
	%slzite::metadata = ();
	my ($front_matter, $body) = split(/\n---\n/, "$$title_ref\n$$body_ref", 2);
	if (!defined($body)) {
		$body = $front_matter;
		$front_matter = "";
	}
	foreach (split /\n/, $front_matter) {
		if (/^([^:]+):\s*(.+)/) {
			$slzite::metadata{$1} = $2;
		}
	}
	$body =~ s/^\s*(?:#{1,3}\s+(.*)(?:\s+\#{1,3})?|(.*)\r?\n[-=]+\s*)$//m;
	$$title_ref = $1 || $2;
	$$body_ref = $body;

	return 1;
}

sub end {
	# Copy over the entire data tree to the output directory so that static assets can be served out of there.
	find(sub {
		my $src = $File::Find::name;
		if ($src =~ m!^$blosxom::datadir(.*?/?)([^/]*?\.?)([^\.]*?)$!) {
			my $dest = "$blosxom::static_dir$1$2$3";
			if (-d $src && ! -e $dest) {
				# Mirror a directory.
				mkpath($dest);
			} elsif ($3 ne $blosxom::file_extension) {
				# Check if the file needs to be updated.
				# -M returns the age of the file since the main script has started, so the bigger, the older.
				if (! -e $dest || -M $dest > -M $src) {
					print "$src â†’ $dest\n";
					copy($src, $dest);
				}
			}
		}
	}, $blosxom::datadir);
	return 1;
}

1;
