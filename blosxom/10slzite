package slzite;

use warnings;
use strict;
use Time::Local;
use File::Find;
use File::stat;
use File::Copy;
use File::Path;
use FileHandle;
use URI::Escape;

use vars qw($w3c_validator_url);

sub start {
	# Ensure that this plugin is enabled only when building statically.
	if ($blosxom::static_or_dynamic eq "dynamic") {
		warn "slzite plugin is disabled in dynamic mode";
		return 0;
	}
	return 1;
}

sub template {
	return sub {
		my ($path, $chunk, $flavour) = @_;
		# Customized flavours are stored in the plugin directory.
		if (open(my $fh, "< $blosxom::plugin_dir/$chunk.$flavour")) {
			return join "", <$fh>;
		} else {
			# Use Blosxom's built-in RSS etc., templates.
			return join "", $blosxom::template{$flavour}{$chunk} || "";
		};
	};
}

sub entries {
	return sub {
		my (%files, %indexes);
		find(sub {
			my $src = $File::Find::name;
			if ((
				$src =~ m!^$blosxom::datadir/((.+)/([^\.].*)\.$blosxom::file_extension)$!
				or $src =~ m!^$blosxom::datadir/(()([^\.].*)\.$blosxom::file_extension)$!
			) and $3 ne "index") {
				# Read post date from the front matter.
				my $date = extract_date($src) || timegm(0, 0, 0, 1, 0, 1970);

				# Add the file and its date to the hash of files.
				$files{$src} = $date;

				# Add indices to be statically rendered if the index has not been overriden.
				my $static_file = "$blosxom::static_dir/$2/index." . $blosxom::static_flavours[0];
				if ((! -f $static_file or -M $static_file > -M $src)) {
					$indexes{$2} = 1;
					my $d = join("/", (blosxom::nice_date($date))[5, 2, 3]);
					$indexes{$d} = $d;
					$indexes{$1} = 1;
				}
			} elsif ($src =~ m!^$blosxom::datadir(.*?/?)([^/]*?\.?)([^\.]*?)$!) {
				# Copy over the entire data tree to the output directory so that static assets can be served out of there.
				my $dest = "$blosxom::static_dir$1$2$3";
				if (-d $src) {
					# Mirror a directory.
					-e $dest or mkpath($dest);
				} elsif ($3 ne $blosxom::file_extension) {
					# Check if the file needs to be updated.
					# -M returns the age of the file since the main script has started, so the bigger, the older.
					if (! -e $dest || -M $dest > -M $src) {
						print "$src â†’ $dest\n";
						copy($src, $dest);
					}
				}
			}
		}, $blosxom::datadir);
		return (\%files, \%indexes);
	};
}

# extract_date(filename) reads the date from the post front matter.
sub extract_date {
	open(my $fh, shift);
	my $inside_front_matter = 0;
	while (<$fh>) {
		if ($inside_front_matter) {
			if (/^\s*date:\s*(\d\d\d\d)-(\d\d)-(\d\d)/) {
				close $fh;
				return timegm(0, 0, 0, $3, $2 - 1, $1);
			} elsif (/^---$/) {
				close $fh;
				return 0;
			}
		} elsif (/^---$/) {
			$inside_front_matter = 1;
		} else {
			close $fh;
			return 0;
		}
	}
	return 0;
}

sub head {
	my ($pkg, $path, $head_ref) = @_;

	# Append a readme found in the current directory to the head.
	# No readme is appended if $path is a file, because the open fails.
	if (
		!$blosxom::path_info_yr and $blosxom::flavour eq "html"
			and open(my $fh, "< $blosxom::datadir/$path/index.$blosxom::file_extension")
	) {
		my $readme = MultiMarkdown::Markdown(join("", <$fh>));
		$$head_ref .= qq{<div class="readme">$readme</div><hr>};
		close $fh;
	}

	# Make the W3C Markup Validator URL.
	$w3c_validator_url = "https://salenzo.neocities.org/$path";
	$w3c_validator_url = uri_escape($w3c_validator_url);
	$w3c_validator_url = "http://validator.w3.org/check?uri=$w3c_validator_url";

	return 1;
}

sub sort {
	return sub {
		my ($files_ref) = @_;
		# Sort posts with the same date alphabetically.
		return sort {
			$files_ref->{$b} <=> $files_ref->{$a} or $a cmp $b;
		} keys %$files_ref;
	}
};

sub story {
	my ($pkg, $path, $filename, $story_ref, $title_ref, $body_ref) = @_;

	# Replace the template for post indices.
	if ($blosxom::path_info =~ m!^(?:.*/)?(index\.$blosxom::flavour|[^\.]*)$!) {
		if ($blosxom::path_info eq "" and !$blosxom::path_info_yr) {
			# Disable post listing for site root.
			$$story_ref = "";
		} else {
			my $entries = &$blosxom::template($blosxom::path, "entries", $blosxom::flavour);
			$$story_ref = $entries if ($entries);
		}
	}
	# Parse the front matter into a global hash and strip it from the body.
	# Extract the title of the article from the Markdown source.
	%slzite::metadata = ();
	my ($front_matter, $body) = split(/\n---\n/, "$$title_ref\n$$body_ref", 2);
	if (!defined($body)) {
		$body = $front_matter;
		$front_matter = "";
	}
	foreach (split /\n/, $front_matter) {
		if (/^([^:]+):\s*(.+)/) {
			$slzite::metadata{$1} = $2;
		}
	}
	$body =~ m/^\s*(?:#{1,3}\s+(.*)(?:\s+\#{1,3})?|(.*)\r?\n[-=]+\s*)$/;
	$$title_ref = $slzite::metadata{"title"} || $1 || $2;
	$$body_ref = $body;

	return 1;
}

1;
